server {
    listen 80;
    server_name localhost;

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    location / {
        # --- CORS 跨域配置 ---
        # 现代浏览器在发送真正的跨域请求（如 POST, PUT, DELETE 或带有自定义头的 GET）之前，
        # 会先发送一个 "预检" 请求 (preflight request)，使用的是 OPTIONS 方法。
        # 我们需要正确地响应这个预检请求。
        
        # 如果请求方法是 OPTIONS（预检请求）
        if ($request_method = 'OPTIONS') {
            # 允许来自任何源的跨域请求。
            # 在生产环境中，为了安全，建议你将其替换为你的前端域名，例如：
            # add_header 'Access-Control-Allow-Origin' 'https://your-frontend-domain.com';
            add_header 'Access-Control-Allow-Origin' '*';

            # 允许的 HTTP 方法。
            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, PATCH, OPTIONS';
            
            # 允许客户端（浏览器）在实际请求中携带这些头部。
            add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';
            
            # 允许浏览器缓存预检请求的结果（单位：秒）。
            # 这可以减少不必要的预检请求次数。
            add_header 'Access-Control-Max-Age' 1728000;
            
            # 对于预检请求，我们直接返回 204 No Content，表示成功处理，
            # 并且不需要返回任何内容主体。
            return 204;
        }

        # --- 对于非预检的实际请求，我们也需要添加 CORS 头部 ---
        # 允许来自任何源的跨域请求。
        # 注意：这里的值需要和上面 OPTIONS 请求中的保持一致。
        add_header 'Access-Control-Allow-Origin' '*';
        # 允许浏览器读取响应中的 'Content-Length', 'Content-Range' 等头部。
        add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';
        # 允许客户端在跨域请求中携带凭证（如 Cookies）。
        # 如果前端请求中设置了 withCredentials = true，这个头部是必需的。
        add_header 'Access-Control-Allow-Credentials' 'true';


        # --- 反向代理核心配置 ---
        proxy_pass http://nest-app:3003;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # --- WebSocket 支持 ---
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}